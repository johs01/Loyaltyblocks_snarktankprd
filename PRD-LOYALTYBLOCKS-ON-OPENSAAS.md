# LoyaltyBlocks MVP - Implementation Guide for Open SaaS

**Product Requirements Document**
**Target Platform:** Open SaaS (Wasp Framework)
**Version:** 1.0
**Audience:** LLM Assistant / AI Development Agent
**Status:** Implementation Ready

---

## üìã Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Open SaaS Foundation Overview](#2-open-saas-foundation-overview)
3. [LoyaltyBlocks Requirements](#3-loyaltyblocks-requirements)
4. [Architecture Mapping](#4-architecture-mapping)
5. [Implementation Phases](#5-implementation-phases)
6. [Phase 1: Database Schema](#phase-1-database-schema)
7. [Phase 2: Multi-Tenant Infrastructure](#phase-2-multi-tenant-infrastructure)
8. [Phase 3: Phone Validation System](#phase-3-phone-validation-system)
9. [Phase 4: Public Customer Registration](#phase-4-public-customer-registration)
10. [Phase 5: Admin Dashboard](#phase-5-admin-dashboard)
11. [Phase 6: Customer CRUD Operations](#phase-6-customer-crud-operations)
12. [Phase 7: Settings Management](#phase-7-settings-management)
13. [Testing & Validation](#testing--validation)
14. [Deployment Checklist](#deployment-checklist)

---

## 1. Executive Summary

### 1.1 Product Overview

**LoyaltyBlocks** is a multi-tenant SaaS platform that enables businesses to:
- Collect customer information via public registration forms
- Manage customer databases with full CRUD operations
- Handle international phone numbers with validation
- Control access through role-based permissions (Super Admin, Manager, Viewer)
- Isolate data completely between organizations (tenants)

### 1.2 Implementation Context

**ASSUMPTION:** You have successfully deployed Open SaaS and it is running locally or in production.

**Starting Point:**
- ‚úÖ Wasp project initialized
- ‚úÖ Authentication working (via Wasp Auth)
- ‚úÖ Database connected (PostgreSQL via Prisma)
- ‚úÖ Basic admin dashboard exists
- ‚úÖ Stripe integration present
- ‚úÖ Landing page functional

**Your Task:**
Transform the Open SaaS boilerplate into LoyaltyBlocks by adding:
1. Multi-tenant customer database
2. Public registration forms (no login required)
3. International phone validation
4. Role-based access control (3 tiers)
5. Organization settings (country selection)

### 1.3 Key Differences from Open SaaS Default

| Feature | Open SaaS Default | LoyaltyBlocks Requirement |
|---------|-------------------|---------------------------|
| Users | Single app users | Multi-tenant organizations |
| Registration | User signup | Public customer registration |
| Access | User-based | Organization-based + RBAC |
| Data Model | Tasks/todos | Customer records |
| Phone Handling | None | International validation (E.164) |
| Settings | User preferences | Organization settings (country) |

---

## 2. Open SaaS Foundation Overview

### 2.1 Technology Stack

Open SaaS uses:
- **Framework:** Wasp (DSL that generates React + Node.js + Prisma)
- **Frontend:** React 18 + TypeScript + Tailwind CSS
- **Backend:** Node.js + Express (auto-generated by Wasp)
- **Database:** PostgreSQL + Prisma ORM
- **Auth:** Wasp Auth (email/password, Google, GitHub)
- **Payments:** Stripe
- **Email:** SendGrid or SMTP

### 2.2 File Structure

```
open-saas/
‚îú‚îÄ‚îÄ main.wasp               # Wasp configuration (routes, auth, entities)
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ client/            # React frontend
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/         # Page components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/    # Reusable components
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ admin/         # Admin dashboard
‚îÇ   ‚îú‚îÄ‚îÄ server/            # Node.js backend
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ actions.ts     # Server actions (mutations)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ queries.ts     # Server queries (reads)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.ts       # Utilities
‚îÇ   ‚îú‚îÄ‚îÄ shared/            # Shared types and constants
‚îÇ   ‚îî‚îÄ‚îÄ .wasproot          # Wasp project marker
‚îú‚îÄ‚îÄ migrations/            # Prisma migrations
‚îî‚îÄ‚îÄ .env.server            # Environment variables
```

### 2.3 Wasp Concepts (Critical to Understand)

#### **Entities (Database Models)**
Defined in `main.wasp`, implemented via Prisma:
```wasp
entity User {=psl
  id          Int      @id @default(autoincrement())
  email       String   @unique
  createdAt   DateTime @default(now())
psl=}
```

#### **Queries (Read Operations)**
```wasp
query getCustomers {
  fn: import { getCustomers } from "@server/queries.js",
  entities: [Customer]
}
```

#### **Actions (Write Operations)**
```wasp
action createCustomer {
  fn: import { createCustomer } from "@server/actions.js",
  entities: [Customer]
}
```

#### **Routes (Pages)**
```wasp
route CustomerListRoute { path: "/customers", to: CustomerListPage }
page CustomerListPage {
  component: import CustomerList from "@client/pages/CustomerList.tsx"
}
```

#### **Authorization**
```wasp
query getCustomers {
  fn: import { getCustomers } from "@server/queries.js",
  entities: [Customer],
  auth: true  // Requires authentication
}
```

### 2.4 What Open SaaS Provides Out-of-the-Box

‚úÖ **Already Built:**
- User authentication (login/signup)
- User sessions and cookies
- Basic admin layout
- Stripe subscription management
- Email sending (transactional)
- Landing page with pricing
- Terms & Privacy pages

‚ö†Ô∏è **Not Built (You Need to Add):**
- Multi-tenancy (organization concept)
- Public forms (non-authenticated access)
- Customer database
- Phone validation
- Role-based permissions
- Organization settings

---

## 3. LoyaltyBlocks Requirements

### 3.1 Core Features

#### **F1: Multi-Tenant Organizations**
- Each organization (tenant) has isolated data
- Users belong to one organization
- Organization has settings (country)
- First user becomes Super Admin automatically

#### **F2: Customer Database**
Each customer record contains:
- **Required:** First name, last name, phone (E.164), birth date
- **Optional:** Email, address (line1, line2, city, state, postal code, country)
- **Metadata:** Created at, updated at, created by, updated by
- **Constraint:** Phone must be unique per organization

#### **F3: Public Customer Registration**
- Public URL: `/{orgSlug}/register` (no login required)
- Form fields: All customer fields
- Real-time phone validation (format + uniqueness)
- Consent checkbox (required)
- Success page after submission

#### **F4: Role-Based Access Control (RBAC)**

| Role | Permissions |
|------|-------------|
| **Super Admin** | Full access: manage users, settings, customers |
| **Manager** | Manage customers (CRUD), view all data |
| **Viewer** | Read-only access to customers |

#### **F5: Phone Number System**
- **Storage Format:** E.164 (e.g., `+15551234567`)
- **Display Format:** Based on organization's country setting
- **Validation:** Using `libphonenumber-js`
- **Supported Countries:** 47+ countries
- **Uniqueness:** Per organization (same phone can exist in different orgs)

#### **F6: Admin Dashboard**
- Customer list with search and pagination
- Customer detail view
- Customer create/edit/delete (based on role)
- User management (Super Admin only)
- Organization settings (Super Admin only)

### 3.2 User Stories

**As a Business Owner (Super Admin):**
- I can share a public registration link with customers
- I can view all registered customers in my dashboard
- I can add customers manually from the admin panel
- I can edit customer information
- I can invite team members with specific roles
- I can change organization settings (e.g., country)

**As a Customer (Public User):**
- I can register via a public form without creating an account
- I see real-time validation of my phone number
- I receive immediate confirmation after registration
- My data is stored securely

**As a Manager:**
- I can view all customers in my organization
- I can add, edit, and delete customers
- I cannot manage users or change settings

**As a Viewer:**
- I can view customer list and details
- I cannot modify any data

### 3.3 Technical Requirements

#### **TR1: Data Isolation**
Every database query MUST filter by `organizationId`:
```typescript
// ‚úÖ CORRECT
const customers = await context.entities.Customer.findMany({
  where: { organizationId: user.organizationId }
});

// ‚ùå WRONG - Data leak risk!
const customers = await context.entities.Customer.findMany({});
```

#### **TR2: Phone Validation**
- Install: `libphonenumber-js`
- Validate format using country code
- Check uniqueness in database
- Store in E.164 format
- Display formatted based on org settings

#### **TR3: First User Logic**
When first customer registers via public form:
1. Create organization if it doesn't exist
2. Create customer record
3. DO NOT create user account (customers ‚â† users)

When organization invites first internal user:
1. Create user record
2. Assign role: `SUPER_ADMIN`
3. Link to Wasp Auth

#### **TR4: Authentication vs Authorization**
- **Authentication (Wasp):** Who you are (handled by Wasp Auth)
- **Authorization (Custom):** What you can do (based on role)
- Public registration: NO authentication required
- Admin dashboard: Authentication + role check required

---

## 4. Architecture Mapping

### 4.1 Open SaaS ‚Üí LoyaltyBlocks Entity Mapping

| Open SaaS Entity | LoyaltyBlocks Entity | Relationship |
|------------------|----------------------|--------------|
| `User` | `User` | Keep, add `role` and `organizationId` |
| N/A | `Organization` | NEW - tenant container |
| N/A | `Customer` | NEW - registered customers |
| N/A | `OrganizationSettings` | NEW - per-org config |
| `Task` | DELETE | Remove (example entity) |

### 4.2 URL Structure

| Route Type | Open SaaS | LoyaltyBlocks |
|------------|-----------|---------------|
| Landing | `/` | `/` (keep) |
| Auth | `/login`, `/signup` | Keep for internal users |
| Admin | `/admin/dashboard` | `/admin/customers` |
| Public | N/A | `/{orgSlug}/register` |
| Settings | `/settings` | `/admin/settings` |

### 4.3 Component Reuse

| Open SaaS Component | Reuse for LoyaltyBlocks |
|---------------------|-------------------------|
| `AdminLayout.tsx` | ‚úÖ Yes - add navigation items |
| `AuthPageLayout.tsx` | ‚úÖ Yes - for internal user login |
| Stripe components | ‚ö†Ô∏è Optional - keep if monetizing |
| Landing page | ‚úÖ Yes - update copy |
| User settings | ‚ö†Ô∏è Partial - move to org settings |

---

## 5. Implementation Phases

### Overview

| Phase | Description | Estimated Time | Dependencies |
|-------|-------------|----------------|--------------|
| 1 | Database Schema | 2 hours | None |
| 2 | Multi-Tenant Infrastructure | 3 hours | Phase 1 |
| 3 | Phone Validation System | 2 hours | Phase 1 |
| 4 | Public Customer Registration | 4 hours | Phase 2, 3 |
| 5 | Admin Dashboard | 3 hours | Phase 2 |
| 6 | Customer CRUD Operations | 5 hours | Phase 5 |
| 7 | Settings Management | 2 hours | Phase 2 |

**Total Estimated Time:** 21 hours (3 days for an LLM with human review)

---

## Phase 1: Database Schema

### 1.1 Update `main.wasp` Entities

**Location:** `main.wasp` (root directory)

**Task:** Replace existing entities with LoyaltyBlocks schema.

```wasp
// ============================================
// ENTITIES (Database Models)
// ============================================

entity Organization {=psl
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  users       User[]
  customers   Customer[]
  settings    OrganizationSettings?

  @@map("organizations")
psl=}

entity User {=psl
  id              String   @id @default(cuid())
  email           String   @unique

  // Multi-tenant fields
  organizationId  String
  role            UserRole @default(VIEWER)

  // Personal info
  firstName       String?
  lastName        String?

  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  customersCreated Customer[] @relation("CustomerCreator")
  customersUpdated Customer[] @relation("CustomerUpdater")

  @@index([organizationId])
  @@map("users")
psl=}

entity Customer {=psl
  id              String   @id @default(cuid())
  organizationId  String

  // Required fields
  firstName       String
  lastName        String
  phone           String   // E.164 format: +15551234567
  birthDate       DateTime

  // Optional contact info
  email           String?
  addressLine1    String?
  addressLine2    String?
  city            String?
  state           String?
  postalCode      String?
  country         String?

  // Metadata
  consentGiven    Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  createdBy       String?
  updatedBy       String?

  // Relations
  organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  creator         User? @relation("CustomerCreator", fields: [createdBy], references: [id], onDelete: SetNull)
  updater         User? @relation("CustomerUpdater", fields: [updatedBy], references: [id], onDelete: SetNull)

  // Constraints
  @@unique([organizationId, phone])
  @@index([organizationId])
  @@index([phone])
  @@index([organizationId, lastName])
  @@map("customers")
psl=}

entity OrganizationSettings {=psl
  id              String   @id @default(cuid())
  organizationId  String   @unique

  // Settings
  country         String   @default("United States")

  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@map("organization_settings")
psl=}

enum UserRole {
  SUPER_ADMIN
  MANAGER
  VIEWER
}
```

### 1.2 Run Database Migration

**Commands to execute:**

```bash
# Step 1: Generate Prisma schema from Wasp
wasp db migrate-dev

# When prompted for migration name, enter:
# "add_loyaltyblocks_schema"

# Step 2: This will:
# - Generate Prisma client
# - Create migration files
# - Apply migration to database
# - Update schema.prisma

# Expected output:
# ‚úî Database schema updated
# ‚úî Migration created: 20240118120000_add_loyaltyblocks_schema
```

### 1.3 Verify Migration

**Check these files were created:**
```
migrations/
‚îî‚îÄ‚îÄ 20240118120000_add_loyaltyblocks_schema/
    ‚îî‚îÄ‚îÄ migration.sql
```

**Verify in database:**
```bash
# Open Prisma Studio
wasp db studio

# Check these tables exist:
# - organizations
# - users (updated with organizationId, role)
# - customers
# - organization_settings
```

---

## Phase 2: Multi-Tenant Infrastructure

### 2.1 Create Organization Utilities

**File:** `src/server/organizations.ts` (NEW FILE)

```typescript
import { Organization, User, OrganizationSettings } from '@wasp/entities';
import HttpError from '@wasp/core/HttpError.js';

/**
 * Get organization by slug
 */
export async function getOrganizationBySlug(
  slug: string,
  context: any
): Promise<Organization | null> {
  return context.entities.Organization.findUnique({
    where: { slug },
    include: { settings: true },
  });
}

/**
 * Create new organization (for first customer registration)
 */
export async function createOrganization(
  data: { name: string; slug: string },
  context: any
): Promise<Organization> {
  try {
    return await context.entities.Organization.create({
      data: {
        name: data.name,
        slug: data.slug,
        settings: {
          create: {
            country: 'United States',
          },
        },
      },
      include: { settings: true },
    });
  } catch (error: any) {
    if (error.code === 'P2002') {
      throw new HttpError(400, 'Organization slug already exists');
    }
    throw error;
  }
}

/**
 * Get or create organization settings
 */
export async function getOrganizationSettings(
  organizationId: string,
  context: any
): Promise<OrganizationSettings> {
  let settings = await context.entities.OrganizationSettings.findUnique({
    where: { organizationId },
  });

  if (!settings) {
    settings = await context.entities.OrganizationSettings.create({
      data: {
        organizationId,
        country: 'United States',
      },
    });
  }

  return settings;
}

/**
 * Check if user has minimum required role
 */
export function hasMinimumRole(
  userRole: string,
  requiredRole: 'SUPER_ADMIN' | 'MANAGER' | 'VIEWER'
): boolean {
  const hierarchy = {
    SUPER_ADMIN: 3,
    MANAGER: 2,
    VIEWER: 1,
  };

  return hierarchy[userRole as keyof typeof hierarchy] >= hierarchy[requiredRole];
}

/**
 * Verify user has access to organization
 */
export function verifyOrganizationAccess(
  user: User,
  organizationId: string
): void {
  if (user.organizationId !== organizationId) {
    throw new HttpError(403, 'Access denied to this organization');
  }
}

/**
 * Check if user is first in organization
 */
export async function isFirstUser(
  organizationId: string,
  context: any
): Promise<boolean> {
  const userCount = await context.entities.User.count({
    where: { organizationId },
  });
  return userCount === 0;
}
```

### 2.2 Update User Model with Organization

**File:** `src/server/auth.ts` (UPDATE EXISTING FILE)

Add helper to get current user with organization:

```typescript
import { User } from '@wasp/entities';
import HttpError from '@wasp/core/HttpError.js';

/**
 * Get authenticated user with organization check
 */
export async function getAuthenticatedUser(context: any): Promise<User> {
  if (!context.user) {
    throw new HttpError(401, 'Not authenticated');
  }

  const user = await context.entities.User.findUnique({
    where: { id: context.user.id },
    include: { organization: true },
  });

  if (!user) {
    throw new HttpError(404, 'User not found');
  }

  return user;
}

/**
 * Require specific role (throws if insufficient)
 */
export function requireRole(
  user: User,
  minimumRole: 'SUPER_ADMIN' | 'MANAGER' | 'VIEWER'
): void {
  const hierarchy = {
    SUPER_ADMIN: 3,
    MANAGER: 2,
    VIEWER: 1,
  };

  const userLevel = hierarchy[user.role as keyof typeof hierarchy] || 0;
  const requiredLevel = hierarchy[minimumRole];

  if (userLevel < requiredLevel) {
    throw new HttpError(403, `Requires ${minimumRole} role or higher`);
  }
}
```

### 2.3 Create Role Permissions Constants

**File:** `src/shared/roles.ts` (NEW FILE)

```typescript
export const ROLE_PERMISSIONS = {
  SUPER_ADMIN: {
    canManageUsers: true,
    canManageSettings: true,
    canCreateCustomers: true,
    canEditCustomers: true,
    canDeleteCustomers: true,
    canViewCustomers: true,
  },
  MANAGER: {
    canManageUsers: false,
    canManageSettings: false,
    canCreateCustomers: true,
    canEditCustomers: true,
    canDeleteCustomers: true,
    canViewCustomers: true,
  },
  VIEWER: {
    canManageUsers: false,
    canManageSettings: false,
    canCreateCustomers: false,
    canEditCustomers: false,
    canDeleteCustomers: false,
    canViewCustomers: true,
  },
} as const;

export type UserRole = keyof typeof ROLE_PERMISSIONS;

export function canPerformAction(
  role: UserRole,
  action: keyof typeof ROLE_PERMISSIONS.SUPER_ADMIN
): boolean {
  return ROLE_PERMISSIONS[role][action];
}
```

---

## Phase 3: Phone Validation System

### 3.1 Install Phone Library

**Command:**
```bash
npm install libphonenumber-js
npm install --save-dev @types/libphonenumber-js
```

### 3.2 Create Country Data

**File:** `src/shared/countries.ts` (NEW FILE)

```typescript
export interface CountryInfo {
  code: string;        // "US"
  name: string;        // "United States"
  dialCode: string;    // "+1"
}

export const COUNTRIES: CountryInfo[] = [
  { code: 'US', name: 'United States', dialCode: '+1' },
  { code: 'CA', name: 'Canada', dialCode: '+1' },
  { code: 'GB', name: 'United Kingdom', dialCode: '+44' },
  { code: 'AU', name: 'Australia', dialCode: '+61' },
  { code: 'NZ', name: 'New Zealand', dialCode: '+64' },
  { code: 'DE', name: 'Germany', dialCode: '+49' },
  { code: 'FR', name: 'France', dialCode: '+33' },
  { code: 'IT', name: 'Italy', dialCode: '+39' },
  { code: 'ES', name: 'Spain', dialCode: '+34' },
  { code: 'NL', name: 'Netherlands', dialCode: '+31' },
  { code: 'BE', name: 'Belgium', dialCode: '+32' },
  { code: 'CH', name: 'Switzerland', dialCode: '+41' },
  { code: 'AT', name: 'Austria', dialCode: '+43' },
  { code: 'SE', name: 'Sweden', dialCode: '+46' },
  { code: 'NO', name: 'Norway', dialCode: '+47' },
  { code: 'DK', name: 'Denmark', dialCode: '+45' },
  { code: 'FI', name: 'Finland', dialCode: '+358' },
  { code: 'IE', name: 'Ireland', dialCode: '+353' },
  { code: 'PT', name: 'Portugal', dialCode: '+351' },
  { code: 'PL', name: 'Poland', dialCode: '+48' },
  { code: 'CZ', name: 'Czech Republic', dialCode: '+420' },
  { code: 'HU', name: 'Hungary', dialCode: '+36' },
  { code: 'GR', name: 'Greece', dialCode: '+30' },
  { code: 'RO', name: 'Romania', dialCode: '+40' },
  { code: 'BG', name: 'Bulgaria', dialCode: '+359' },
  { code: 'HR', name: 'Croatia', dialCode: '+385' },
  { code: 'SI', name: 'Slovenia', dialCode: '+386' },
  { code: 'SK', name: 'Slovakia', dialCode: '+421' },
  { code: 'LT', name: 'Lithuania', dialCode: '+370' },
  { code: 'LV', name: 'Latvia', dialCode: '+371' },
  { code: 'EE', name: 'Estonia', dialCode: '+372' },
  { code: 'IS', name: 'Iceland', dialCode: '+354' },
  { code: 'LU', name: 'Luxembourg', dialCode: '+352' },
  { code: 'MT', name: 'Malta', dialCode: '+356' },
  { code: 'CY', name: 'Cyprus', dialCode: '+357' },
  { code: 'JP', name: 'Japan', dialCode: '+81' },
  { code: 'KR', name: 'South Korea', dialCode: '+82' },
  { code: 'CN', name: 'China', dialCode: '+86' },
  { code: 'IN', name: 'India', dialCode: '+91' },
  { code: 'SG', name: 'Singapore', dialCode: '+65' },
  { code: 'MY', name: 'Malaysia', dialCode: '+60' },
  { code: 'TH', name: 'Thailand', dialCode: '+66' },
  { code: 'PH', name: 'Philippines', dialCode: '+63' },
  { code: 'ID', name: 'Indonesia', dialCode: '+62' },
  { code: 'VN', name: 'Vietnam', dialCode: '+84' },
  { code: 'BR', name: 'Brazil', dialCode: '+55' },
  { code: 'MX', name: 'Mexico', dialCode: '+52' },
  { code: 'AR', name: 'Argentina', dialCode: '+54' },
].sort((a, b) => a.name.localeCompare(b.name));

export function getCountryByName(name: string): CountryInfo | undefined {
  return COUNTRIES.find((c) => c.name === name);
}

export function getCountryByCode(code: string): CountryInfo | undefined {
  return COUNTRIES.find((c) => c.code === code);
}
```

### 3.3 Create Phone Validation Utilities

**File:** `src/server/phoneValidation.ts` (NEW FILE)

```typescript
import {
  parsePhoneNumber,
  isValidPhoneNumber,
  type CountryCode,
} from 'libphonenumber-js';
import HttpError from '@wasp/core/HttpError.js';
import { Customer } from '@wasp/entities';

export interface PhoneValidationResult {
  isValid: boolean;
  formatted?: string; // E.164 format
  error?: string;
}

/**
 * Validate and format phone to E.164
 */
export function validateAndFormatPhone(
  phoneInput: string,
  countryCode: string
): PhoneValidationResult {
  try {
    const cleaned = phoneInput.replace(/[\s\-\(\)\.]/g, '');

    if (!cleaned) {
      return { isValid: false, error: 'Phone number is required' };
    }

    const isValid = isValidPhoneNumber(cleaned, countryCode as CountryCode);

    if (!isValid) {
      return { isValid: false, error: 'Invalid phone number format' };
    }

    const phoneNumber = parsePhoneNumber(cleaned, countryCode as CountryCode);

    return {
      isValid: true,
      formatted: phoneNumber.format('E.164'),
    };
  } catch (error) {
    return { isValid: false, error: 'Failed to parse phone number' };
  }
}

/**
 * Format E.164 phone for display
 */
export function formatPhoneForDisplay(
  e164Phone: string,
  format: 'national' | 'international' = 'national'
): string {
  try {
    const phoneNumber = parsePhoneNumber(e164Phone);
    return format === 'national'
      ? phoneNumber.formatNational()
      : phoneNumber.formatInternational();
  } catch {
    return e164Phone;
  }
}

/**
 * Check if phone is available (not already registered)
 */
export async function checkPhoneAvailability(
  phone: string,
  organizationId: string,
  context: any,
  excludeCustomerId?: string
): Promise<{ available: boolean; message: string }> {
  const existingCustomer = await context.entities.Customer.findFirst({
    where: {
      organizationId,
      phone,
      ...(excludeCustomerId && { id: { not: excludeCustomerId } }),
    },
    select: {
      id: true,
      firstName: true,
      lastName: true,
    },
  });

  if (existingCustomer) {
    return {
      available: false,
      message: `Phone already registered to ${existingCustomer.firstName} ${existingCustomer.lastName}`,
    };
  }

  return {
    available: true,
    message: 'Phone number is available',
  };
}

/**
 * Validate phone format AND check availability
 */
export async function validatePhoneComplete(
  phoneInput: string,
  countryCode: string,
  organizationId: string,
  context: any,
  excludeCustomerId?: string
): Promise<PhoneValidationResult & { available?: boolean }> {
  // First validate format
  const validation = validateAndFormatPhone(phoneInput, countryCode);

  if (!validation.isValid || !validation.formatted) {
    return validation;
  }

  // Then check availability
  const availability = await checkPhoneAvailability(
    validation.formatted,
    organizationId,
    context,
    excludeCustomerId
  );

  return {
    ...validation,
    available: availability.available,
    error: !availability.available ? availability.message : undefined,
  };
}
```

---

## Phase 4: Public Customer Registration

### 4.1 Define Public Registration Action

**File:** `main.wasp` (ADD TO FILE)

```wasp
// ============================================
// PUBLIC CUSTOMER REGISTRATION
// ============================================

action registerCustomer {
  fn: import { registerCustomer } from "@server/actions.js",
  entities: [Organization, Customer, OrganizationSettings]
  // NOTE: No auth: true - this is public!
}

action validatePhone {
  fn: import { validatePhone } from "@server/actions.js",
  entities: [Customer]
  // NOTE: No auth: true - this is public!
}

route PublicRegisterRoute {
  path: "/:orgSlug/register",
  to: PublicRegisterPage
}

page PublicRegisterPage {
  component: import PublicRegister from "@client/pages/PublicRegister.tsx"
  // NOTE: No authRequired - public page
}
```

### 4.2 Implement Registration Action

**File:** `src/server/actions.ts` (ADD TO FILE)

```typescript
import { Customer } from '@wasp/entities';
import HttpError from '@wasp/core/HttpError.js';
import {
  getOrganizationBySlug,
  createOrganization,
  getOrganizationSettings,
} from './organizations.js';
import { validatePhoneComplete } from './phoneValidation.js';

type RegisterCustomerInput = {
  orgSlug: string;
  firstName: string;
  lastName: string;
  phone: string;
  birthDate: string; // ISO date string
  email?: string;
  addressLine1?: string;
  addressLine2?: string;
  city?: string;
  state?: string;
  postalCode?: string;
  country?: string;
  consentGiven: boolean;
};

type RegisterCustomerOutput = {
  customerId: string;
  isFirstCustomer: boolean;
};

/**
 * Public customer registration (no auth required)
 */
export async function registerCustomer(
  args: RegisterCustomerInput,
  context: any
): Promise<RegisterCustomerOutput> {
  // Validate consent
  if (!args.consentGiven) {
    throw new HttpError(400, 'Consent is required');
  }

  // Get or create organization
  let organization = await getOrganizationBySlug(args.orgSlug, context);
  let isFirstCustomer = false;

  if (!organization) {
    // First customer - create organization
    const orgName = args.orgSlug
      .split('-')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');

    organization = await createOrganization(
      { name: orgName, slug: args.orgSlug },
      context
    );
    isFirstCustomer = true;
  }

  // Get organization settings
  const settings = await getOrganizationSettings(organization.id, context);

  // Validate phone
  const phoneValidation = await validatePhoneComplete(
    args.phone,
    settings.country,
    organization.id,
    context
  );

  if (!phoneValidation.isValid || !phoneValidation.available) {
    throw new HttpError(400, phoneValidation.error || 'Invalid phone number');
  }

  // Create customer
  try {
    const customer = await context.entities.Customer.create({
      data: {
        organizationId: organization.id,
        firstName: args.firstName.trim(),
        lastName: args.lastName.trim(),
        phone: phoneValidation.formatted!,
        birthDate: new Date(args.birthDate),
        email: args.email?.trim() || null,
        addressLine1: args.addressLine1?.trim() || null,
        addressLine2: args.addressLine2?.trim() || null,
        city: args.city?.trim() || null,
        state: args.state?.trim() || null,
        postalCode: args.postalCode?.trim() || null,
        country: args.country || null,
        consentGiven: args.consentGiven,
        createdBy: null, // Public registration
        updatedBy: null,
      },
    });

    return {
      customerId: customer.id,
      isFirstCustomer,
    };
  } catch (error: any) {
    console.error('Customer creation error:', error);
    throw new HttpError(500, 'Failed to register customer');
  }
}

type ValidatePhoneInput = {
  phone: string;
  countryCode: string;
  orgSlug: string;
};

type ValidatePhoneOutput = {
  isValid: boolean;
  available: boolean;
  formatted?: string;
  error?: string;
};

/**
 * Validate phone (public endpoint for real-time validation)
 */
export async function validatePhone(
  args: ValidatePhoneInput,
  context: any
): Promise<ValidatePhoneOutput> {
  const organization = await getOrganizationBySlug(args.orgSlug, context);

  if (!organization) {
    return {
      isValid: false,
      available: false,
      error: 'Organization not found',
    };
  }

  const result = await validatePhoneComplete(
    args.phone,
    args.countryCode,
    organization.id,
    context
  );

  return {
    isValid: result.isValid,
    available: result.available || false,
    formatted: result.formatted,
    error: result.error,
  };
}
```

### 4.3 Create Registration Form Component

**File:** `src/client/components/PhoneInput.tsx` (NEW FILE)

```typescript
import React, { useState, useEffect } from 'react';
import { validatePhone } from '@wasp/actions';

interface PhoneInputProps {
  value: string;
  onChange: (value: string, isValid: boolean) => void;
  orgSlug: string;
  countryCode: string;
  skipAvailabilityCheck?: boolean;
}

export default function PhoneInput({
  value,
  onChange,
  orgSlug,
  countryCode,
  skipAvailabilityCheck = false,
}: PhoneInputProps) {
  const [validating, setValidating] = useState(false);
  const [isValid, setIsValid] = useState<boolean | null>(null);
  const [error, setError] = useState<string>('');

  useEffect(() => {
    if (!value || value.length < 7 || skipAvailabilityCheck) {
      setIsValid(null);
      setError('');
      return;
    }

    const timer = setTimeout(async () => {
      setValidating(true);
      try {
        const result = await validatePhone({
          phone: value,
          countryCode,
          orgSlug,
        });

        setIsValid(result.isValid && result.available);
        setError(result.error || '');
        onChange(value, result.isValid && result.available);
      } catch (err) {
        setError('Validation failed');
        setIsValid(false);
        onChange(value, false);
      } finally {
        setValidating(false);
      }
    }, 500); // 500ms debounce

    return () => clearTimeout(timer);
  }, [value, orgSlug, countryCode, skipAvailabilityCheck, onChange]);

  return (
    <div className="space-y-1">
      <label className="block text-sm font-medium text-gray-700">
        Phone Number *
      </label>
      <div className="relative">
        <input
          type="tel"
          value={value}
          onChange={(e) => onChange(e.target.value, false)}
          className={`w-full px-3 py-2 border rounded-md ${
            error ? 'border-red-500' : 'border-gray-300'
          } focus:outline-none focus:ring-2 focus:ring-blue-500`}
          placeholder="(555) 123-4567"
        />
        <div className="absolute right-3 top-2.5">
          {validating && (
            <div className="animate-spin h-5 w-5 border-2 border-blue-500 rounded-full border-t-transparent" />
          )}
          {!validating && isValid === true && (
            <span className="text-green-500 text-xl">‚úì</span>
          )}
          {!validating && isValid === false && error && (
            <span className="text-red-500 text-xl">‚úó</span>
          )}
        </div>
      </div>
      {error && <p className="text-sm text-red-600">{error}</p>}
    </div>
  );
}
```

### 4.4 Create Public Registration Page

**File:** `src/client/pages/PublicRegister.tsx` (NEW FILE)

```typescript
import React, { useState } from 'react';
import { useParams, useHistory } from 'react-router-dom';
import { registerCustomer } from '@wasp/actions';
import PhoneInput from '../components/PhoneInput';

export default function PublicRegister() {
  const { orgSlug } = useParams<{ orgSlug: string }>();
  const history = useHistory();

  const [submitting, setSubmitting] = useState(false);
  const [error, setError] = useState('');

  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
    phone: '',
    birthDate: '',
    email: '',
    addressLine1: '',
    addressLine2: '',
    city: '',
    state: '',
    postalCode: '',
    country: '',
    consentGiven: true,
  });

  const [phoneValid, setPhoneValid] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setSubmitting(true);
    setError('');

    try {
      const result = await registerCustomer({
        orgSlug,
        ...formData,
      });

      // Redirect to success page
      history.push(`/${orgSlug}/register/success`);
    } catch (err: any) {
      setError(err.message || 'Registration failed. Please try again.');
    } finally {
      setSubmitting(false);
    }
  };

  const isFormValid = () => {
    return (
      formData.firstName &&
      formData.lastName &&
      phoneValid &&
      formData.birthDate &&
      formData.consentGiven
    );
  };

  return (
    <div className="min-h-screen bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-2xl mx-auto">
        <div className="bg-white shadow-md rounded-lg px-8 py-10">
          {/* Header */}
          <div className="mb-8">
            <h1 className="text-3xl font-bold text-gray-900 mb-2">
              Customer Registration
            </h1>
            <p className="text-gray-600">
              Please fill out the form below to register.
            </p>
          </div>

          {/* Form */}
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* First Name */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                First Name *
              </label>
              <input
                type="text"
                required
                value={formData.firstName}
                onChange={(e) =>
                  setFormData({ ...formData, firstName: e.target.value })
                }
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>

            {/* Last Name */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Last Name *
              </label>
              <input
                type="text"
                required
                value={formData.lastName}
                onChange={(e) =>
                  setFormData({ ...formData, lastName: e.target.value })
                }
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>

            {/* Phone Input with Validation */}
            <PhoneInput
              value={formData.phone}
              onChange={(value, isValid) => {
                setFormData({ ...formData, phone: value });
                setPhoneValid(isValid);
              }}
              orgSlug={orgSlug}
              countryCode="US"
            />

            {/* Birth Date */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Birth Date *
              </label>
              <input
                type="date"
                required
                value={formData.birthDate}
                onChange={(e) =>
                  setFormData({ ...formData, birthDate: e.target.value })
                }
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>

            {/* Email (Optional) */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Email
              </label>
              <input
                type="email"
                value={formData.email}
                onChange={(e) =>
                  setFormData({ ...formData, email: e.target.value })
                }
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>

            {/* Address Line 1 (Optional) */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Address Line 1
              </label>
              <input
                type="text"
                value={formData.addressLine1}
                onChange={(e) =>
                  setFormData({ ...formData, addressLine1: e.target.value })
                }
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>

            {/* City & State Row */}
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  City
                </label>
                <input
                  type="text"
                  value={formData.city}
                  onChange={(e) =>
                    setFormData({ ...formData, city: e.target.value })
                  }
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  State
                </label>
                <input
                  type="text"
                  value={formData.state}
                  onChange={(e) =>
                    setFormData({ ...formData, state: e.target.value })
                  }
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
            </div>

            {/* Consent */}
            <div className="flex items-start">
              <input
                type="checkbox"
                required
                checked={formData.consentGiven}
                onChange={(e) =>
                  setFormData({ ...formData, consentGiven: e.target.checked })
                }
                className="mt-1 h-4 w-4 text-blue-600 border-gray-300 rounded"
              />
              <label className="ml-2 text-sm text-gray-700">
                I consent to my information being stored for customer management
                purposes. *
              </label>
            </div>

            {/* Error Message */}
            {error && (
              <div className="p-4 bg-red-50 border border-red-200 rounded-md">
                <p className="text-sm text-red-600">{error}</p>
              </div>
            )}

            {/* Submit Button */}
            <button
              type="submit"
              disabled={!isFormValid() || submitting}
              className="w-full bg-blue-600 text-white py-3 px-6 rounded-md hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
            >
              {submitting ? 'Registering...' : 'Register'}
            </button>
          </form>

          {/* Footer */}
          <div className="mt-6 text-center text-sm text-gray-500">
            <p>Your information will be kept confidential and secure.</p>
          </div>
        </div>
      </div>
    </div>
  );
}
```

### 4.5 Create Success Page

**File:** `main.wasp` (ADD TO FILE)

```wasp
route PublicRegisterSuccessRoute {
  path: "/:orgSlug/register/success",
  to: PublicRegisterSuccessPage
}

page PublicRegisterSuccessPage {
  component: import PublicRegisterSuccess from "@client/pages/PublicRegisterSuccess.tsx"
}
```

**File:** `src/client/pages/PublicRegisterSuccess.tsx` (NEW FILE)

```typescript
import React from 'react';
import { useParams, Link } from 'react-router-dom';

export default function PublicRegisterSuccess() {
  const { orgSlug } = useParams<{ orgSlug: string }>();

  return (
    <div className="min-h-screen bg-gray-50 flex items-center justify-center px-4">
      <div className="max-w-md w-full bg-white shadow-md rounded-lg p-8 text-center">
        {/* Success Icon */}
        <div className="mb-6">
          <div className="mx-auto w-16 h-16 bg-green-100 rounded-full flex items-center justify-center">
            <svg
              className="w-8 h-8 text-green-600"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M5 13l4 4L19 7"
              />
            </svg>
          </div>
        </div>

        {/* Success Message */}
        <h1 className="text-2xl font-bold text-gray-900 mb-2">
          Registration Successful!
        </h1>
        <p className="text-gray-600 mb-6">
          Thank you for registering. Your information has been saved securely.
        </p>

        {/* Actions */}
        <Link
          to={`/${orgSlug}/register`}
          className="inline-block bg-blue-600 text-white py-2 px-6 rounded-md hover:bg-blue-700 transition-colors"
        >
          Register Another Customer
        </Link>
      </div>
    </div>
  );
}
```

---

## Phase 5: Admin Dashboard

### 5.1 Update Navigation

**File:** `src/client/admin/AdminLayout.tsx` (UPDATE EXISTING)

Find the navigation section and update:

```typescript
// Add to navigation items
const navItems = [
  {
    name: 'Dashboard',
    href: '/admin/dashboard',
    icon: 'üìä',
    roles: ['SUPER_ADMIN', 'MANAGER', 'VIEWER'],
  },
  {
    name: 'Customers',
    href: '/admin/customers',
    icon: 'üë•',
    roles: ['SUPER_ADMIN', 'MANAGER', 'VIEWER'],
  },
  {
    name: 'Users',
    href: '/admin/users',
    icon: 'üîê',
    roles: ['SUPER_ADMIN'],
  },
  {
    name: 'Settings',
    href: '/admin/settings',
    icon: '‚öôÔ∏è',
    roles: ['SUPER_ADMIN'],
  },
];

// Filter based on user role
const visibleItems = navItems.filter((item) =>
  item.roles.includes(user.role)
);
```

### 5.2 Create Customer List Query

**File:** `main.wasp` (ADD TO FILE)

```wasp
// ============================================
// CUSTOMER QUERIES
// ============================================

query getCustomers {
  fn: import { getCustomers } from "@server/queries.js",
  entities: [Customer, User]
  auth: true
}

query getCustomer {
  fn: import { getCustomer } from "@server/queries.js",
  entities: [Customer, User]
  auth: true
}
```

**File:** `src/server/queries.ts` (ADD TO FILE)

```typescript
import { Customer, User } from '@wasp/entities';
import { getAuthenticatedUser } from './auth.js';
import HttpError from '@wasp/core/HttpError.js';

type GetCustomersInput = {
  search?: string;
  page?: number;
  pageSize?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
};

type GetCustomersOutput = {
  customers: Customer[];
  totalCount: number;
  totalPages: number;
  currentPage: number;
};

/**
 * Get customers for authenticated user's organization
 */
export async function getCustomers(
  args: GetCustomersInput,
  context: any
): Promise<GetCustomersOutput> {
  const user = await getAuthenticatedUser(context);

  const page = args.page || 1;
  const pageSize = args.pageSize || 20;
  const skip = (page - 1) * pageSize;
  const sortBy = args.sortBy || 'createdAt';
  const sortOrder = args.sortOrder || 'desc';

  // Build search filter
  const searchFilter = args.search
    ? {
        OR: [
          { firstName: { contains: args.search, mode: 'insensitive' } },
          { lastName: { contains: args.search, mode: 'insensitive' } },
          { phone: { contains: args.search } },
        ],
      }
    : {};

  const where = {
    organizationId: user.organizationId,
    ...searchFilter,
  };

  // Fetch customers with pagination
  const [customers, totalCount] = await Promise.all([
    context.entities.Customer.findMany({
      where,
      orderBy: { [sortBy]: sortOrder },
      skip,
      take: pageSize,
      include: {
        creator: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
      },
    }),
    context.entities.Customer.count({ where }),
  ]);

  return {
    customers,
    totalCount,
    totalPages: Math.ceil(totalCount / pageSize),
    currentPage: page,
  };
}

type GetCustomerInput = {
  customerId: string;
};

/**
 * Get single customer by ID
 */
export async function getCustomer(
  args: GetCustomerInput,
  context: any
): Promise<Customer> {
  const user = await getAuthenticatedUser(context);

  const customer = await context.entities.Customer.findUnique({
    where: { id: args.customerId },
    include: {
      creator: true,
      updater: true,
    },
  });

  if (!customer) {
    throw new HttpError(404, 'Customer not found');
  }

  // Verify organization access
  if (customer.organizationId !== user.organizationId) {
    throw new HttpError(403, 'Access denied');
  }

  return customer;
}
```

### 5.3 Create Customer List Route

**File:** `main.wasp` (ADD TO FILE)

```wasp
route CustomersRoute {
  path: "/admin/customers",
  to: CustomersPage
}

page CustomersPage {
  component: import Customers from "@client/admin/Customers.tsx",
  authRequired: true
}
```

### 5.4 Create Customer List Page

**File:** `src/client/admin/Customers.tsx` (NEW FILE)

```typescript
import React, { useState } from 'react';
import { useQuery } from '@wasp/queries';
import { getCustomers } from '@wasp/queries';
import { Link } from 'react-router-dom';
import { formatPhoneForDisplay } from '../../server/phoneValidation';

export default function Customers() {
  const [search, setSearch] = useState('');
  const [page, setPage] = useState(1);

  const { data, isLoading, error } = useQuery(getCustomers, {
    search,
    page,
    pageSize: 20,
  });

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-4 bg-red-50 border border-red-200 rounded-md">
        <p className="text-red-600">Error loading customers: {error.message}</p>
      </div>
    );
  }

  const { customers, totalCount, totalPages, currentPage } = data!;

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold text-gray-900">
          Customers ({totalCount})
        </h1>
        <Link
          to="/admin/customers/create"
          className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition-colors"
        >
          + Add Customer
        </Link>
      </div>

      {/* Search */}
      <div>
        <input
          type="text"
          placeholder="Search by name or phone..."
          value={search}
          onChange={(e) => {
            setSearch(e.target.value);
            setPage(1); // Reset to first page on search
          }}
          className="w-full md:w-96 px-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </div>

      {/* Customer Table */}
      <div className="bg-white rounded-lg shadow overflow-hidden">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Name
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Phone
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Birth Date
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Registered
              </th>
              <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                Actions
              </th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {customers.map((customer) => (
              <tr key={customer.id} className="hover:bg-gray-50">
                <td className="px-6 py-4 whitespace-nowrap">
                  <Link
                    to={`/admin/customers/${customer.id}`}
                    className="text-blue-600 hover:text-blue-800 font-medium"
                  >
                    {customer.firstName} {customer.lastName}
                  </Link>
                </td>
                <td className="px-6 py-4 whitespace-nowrap">
                  {formatPhoneForDisplay(customer.phone, 'national')}
                </td>
                <td className="px-6 py-4 whitespace-nowrap">
                  {new Date(customer.birthDate).toLocaleDateString()}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {new Date(customer.createdAt).toLocaleDateString()}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium space-x-3">
                  <Link
                    to={`/admin/customers/${customer.id}/edit`}
                    className="text-blue-600 hover:text-blue-800"
                  >
                    Edit
                  </Link>
                  <button
                    onClick={() => handleDelete(customer.id)}
                    className="text-red-600 hover:text-red-800"
                  >
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* Pagination */}
      {totalPages > 1 && (
        <div className="flex items-center justify-between">
          <div className="text-sm text-gray-700">
            Page {currentPage} of {totalPages}
          </div>
          <div className="flex gap-2">
            <button
              onClick={() => setPage((p) => Math.max(1, p - 1))}
              disabled={currentPage === 1}
              className="px-4 py-2 border border-gray-300 rounded-md hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Previous
            </button>
            <button
              onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
              disabled={currentPage === totalPages}
              className="px-4 py-2 border border-gray-300 rounded-md hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Next
            </button>
          </div>
        </div>
      )}
    </div>
  );

  function handleDelete(customerId: string) {
    if (!confirm('Are you sure you want to delete this customer?')) return;

    // Implement delete action
    console.log('Delete customer:', customerId);
  }
}
```

---

## Phase 6: Customer CRUD Operations

### 6.1 Define Customer Actions

**File:** `main.wasp` (ADD TO FILE)

```wasp
// ============================================
// CUSTOMER ACTIONS (Admin)
// ============================================

action createCustomer {
  fn: import { createCustomer } from "@server/actions.js",
  entities: [Customer],
  auth: true
}

action updateCustomer {
  fn: import { updateCustomer } from "@server/actions.js",
  entities: [Customer],
  auth: true
}

action deleteCustomer {
  fn: import { deleteCustomer } from "@server/actions.js",
  entities: [Customer],
  auth: true
}
```

### 6.2 Implement CRUD Actions

**File:** `src/server/actions.ts` (ADD TO FILE)

```typescript
import { Customer } from '@wasp/entities';
import { getAuthenticatedUser, requireRole } from './auth.js';
import { validatePhoneComplete } from './phoneValidation.js';
import { getOrganizationSettings } from './organizations.js';
import HttpError from '@wasp/core/HttpError.js';

type CustomerInput = {
  firstName: string;
  lastName: string;
  phone: string;
  birthDate: string;
  email?: string;
  addressLine1?: string;
  addressLine2?: string;
  city?: string;
  state?: string;
  postalCode?: string;
  country?: string;
};

/**
 * Create customer (Admin only)
 */
export async function createCustomer(
  args: CustomerInput,
  context: any
): Promise<Customer> {
  const user = await getAuthenticatedUser(context);
  requireRole(user, 'MANAGER'); // Manager or above can create

  const settings = await getOrganizationSettings(user.organizationId, context);

  // Validate phone
  const phoneValidation = await validatePhoneComplete(
    args.phone,
    settings.country,
    user.organizationId,
    context
  );

  if (!phoneValidation.isValid || !phoneValidation.available) {
    throw new HttpError(400, phoneValidation.error || 'Invalid phone');
  }

  return context.entities.Customer.create({
    data: {
      organizationId: user.organizationId,
      firstName: args.firstName.trim(),
      lastName: args.lastName.trim(),
      phone: phoneValidation.formatted!,
      birthDate: new Date(args.birthDate),
      email: args.email?.trim() || null,
      addressLine1: args.addressLine1?.trim() || null,
      addressLine2: args.addressLine2?.trim() || null,
      city: args.city?.trim() || null,
      state: args.state?.trim() || null,
      postalCode: args.postalCode?.trim() || null,
      country: args.country || null,
      consentGiven: true,
      createdBy: user.id,
      updatedBy: user.id,
    },
  });
}

type UpdateCustomerInput = CustomerInput & {
  customerId: string;
};

/**
 * Update customer (Admin only)
 */
export async function updateCustomer(
  args: UpdateCustomerInput,
  context: any
): Promise<Customer> {
  const user = await getAuthenticatedUser(context);
  requireRole(user, 'MANAGER');

  // Get existing customer
  const existing = await context.entities.Customer.findUnique({
    where: { id: args.customerId },
  });

  if (!existing) {
    throw new HttpError(404, 'Customer not found');
  }

  if (existing.organizationId !== user.organizationId) {
    throw new HttpError(403, 'Access denied');
  }

  // Validate phone if changed
  let phoneFormatted = existing.phone;
  if (args.phone !== existing.phone) {
    const settings = await getOrganizationSettings(user.organizationId, context);
    const phoneValidation = await validatePhoneComplete(
      args.phone,
      settings.country,
      user.organizationId,
      context,
      args.customerId // Exclude current customer
    );

    if (!phoneValidation.isValid || !phoneValidation.available) {
      throw new HttpError(400, phoneValidation.error || 'Invalid phone');
    }

    phoneFormatted = phoneValidation.formatted!;
  }

  return context.entities.Customer.update({
    where: { id: args.customerId },
    data: {
      firstName: args.firstName.trim(),
      lastName: args.lastName.trim(),
      phone: phoneFormatted,
      birthDate: new Date(args.birthDate),
      email: args.email?.trim() || null,
      addressLine1: args.addressLine1?.trim() || null,
      addressLine2: args.addressLine2?.trim() || null,
      city: args.city?.trim() || null,
      state: args.state?.trim() || null,
      postalCode: args.postalCode?.trim() || null,
      country: args.country || null,
      updatedBy: user.id,
    },
  });
}

type DeleteCustomerInput = {
  customerId: string;
};

/**
 * Delete customer (Manager+ only)
 */
export async function deleteCustomer(
  args: DeleteCustomerInput,
  context: any
): Promise<{ success: boolean }> {
  const user = await getAuthenticatedUser(context);
  requireRole(user, 'MANAGER');

  const customer = await context.entities.Customer.findUnique({
    where: { id: args.customerId },
  });

  if (!customer) {
    throw new HttpError(404, 'Customer not found');
  }

  if (customer.organizationId !== user.organizationId) {
    throw new HttpError(403, 'Access denied');
  }

  await context.entities.Customer.delete({
    where: { id: args.customerId },
  });

  return { success: true };
}
```

---

## Phase 7: Settings Management

### 7.1 Define Settings Query and Action

**File:** `main.wasp` (ADD TO FILE)

```wasp
// ============================================
// ORGANIZATION SETTINGS
// ============================================

query getSettings {
  fn: import { getSettings } from "@server/queries.js",
  entities: [OrganizationSettings],
  auth: true
}

action updateSettings {
  fn: import { updateSettings } from "@server/actions.js",
  entities: [OrganizationSettings],
  auth: true
}
```

### 7.2 Implement Settings Operations

**File:** `src/server/queries.ts` (ADD TO FILE)

```typescript
import { OrganizationSettings } from '@wasp/entities';
import { getAuthenticatedUser } from './auth.js';
import { getOrganizationSettings } from './organizations.js';

/**
 * Get organization settings
 */
export async function getSettings(args: {}, context: any): Promise<OrganizationSettings> {
  const user = await getAuthenticatedUser(context);
  return getOrganizationSettings(user.organizationId, context);
}
```

**File:** `src/server/actions.ts` (ADD TO FILE)

```typescript
import { OrganizationSettings } from '@wasp/entities';
import { getAuthenticatedUser, requireRole } from './auth.js';
import { COUNTRIES } from '../shared/countries.js';
import HttpError from '@wasp/core/HttpError.js';

type UpdateSettingsInput = {
  country: string;
};

/**
 * Update organization settings (Super Admin only)
 */
export async function updateSettings(
  args: UpdateSettingsInput,
  context: any
): Promise<OrganizationSettings> {
  const user = await getAuthenticatedUser(context);
  requireRole(user, 'SUPER_ADMIN');

  // Validate country
  const validCountry = COUNTRIES.find((c) => c.name === args.country);
  if (!validCountry) {
    throw new HttpError(400, 'Invalid country selected');
  }

  // Upsert settings
  return context.entities.OrganizationSettings.upsert({
    where: { organizationId: user.organizationId },
    update: { country: args.country },
    create: {
      organizationId: user.organizationId,
      country: args.country,
    },
  });
}
```

---

## Testing & Validation

### Test Checklist

```bash
# 1. Test public registration
# - Visit: http://localhost:3000/test-org/register
# - Fill form with valid data
# - Verify phone validation works (real-time)
# - Submit and check success page

# 2. Test admin login
# - Visit: http://localhost:3000/login
# - Create test user in database
# - Login and access /admin/customers

# 3. Test customer list
# - Should show customers from your org only
# - Test search functionality
# - Test pagination

# 4. Test customer CRUD
# - Create new customer
# - Edit existing customer
# - Delete customer (with confirmation)

# 5. Test RBAC
# - Create users with different roles
# - Verify Viewer cannot edit
# - Verify Manager can edit customers
# - Verify only Super Admin sees Settings

# 6. Test multi-tenancy
# - Create two organizations
# - Verify data isolation (org1 cannot see org2 data)
```

---

## Deployment Checklist

```bash
# 1. Environment variables
# Set in production:
# - DATABASE_URL
# - JWT_SECRET (auto-generated by Wasp)
# - All other env vars from .env.server

# 2. Database migration
wasp db migrate-deploy

# 3. Build
wasp build

# 4. Deploy (Fly.io - recommended by Wasp)
wasp deploy fly launch loyaltyblocks
wasp deploy fly deploy

# 5. Verify
# - Test public registration: https://yourdomain.com/test-org/register
# - Test admin: https://yourdomain.com/admin/customers
# - Check database (no errors in logs)
```

---

## Summary

You now have a complete implementation guide for building LoyaltyBlocks on Open SaaS. The key phases are:

1. ‚úÖ **Database Schema** - 4 entities with multi-tenant structure
2. ‚úÖ **Multi-Tenant Infrastructure** - Organization context and RBAC
3. ‚úÖ **Phone Validation** - E.164 storage, 47+ countries
4. ‚úÖ **Public Registration** - No-auth customer signup
5. ‚úÖ **Admin Dashboard** - Protected routes with navigation
6. ‚úÖ **Customer CRUD** - Full management with role checks
7. ‚úÖ **Settings Management** - Per-organization configuration

**Total Implementation Time:** ~21 hours for an LLM with human review

**Next Steps:**
1. Start with Phase 1 (Database Schema)
2. Test each phase before moving to next
3. Deploy to production after Phase 7
4. Iterate based on user feedback

---

**End of PRD**
